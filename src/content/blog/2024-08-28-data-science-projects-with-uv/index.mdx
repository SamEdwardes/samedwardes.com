---
author: Sam Edwardes
date: 2024-08-28
description: How I use uv to manage a Python data science project. uv can replace pyenv, poetry, and pipx.
keywords:
- python
- uv
- pip
tags:
- python
title: Managing Data Science Projects with uv
---

import Callout from '../../../components/Callout.astro'

[Astral](https://astral.sh/) recently announced a slew of new features for uv [https://astral.sh/blog/uv-unified-python-packaging](https://astral.sh/blog/uv-unified-python-packaging). uv is now a complete tool for all of your python needs:

- Managing your Python installation (I used to use [pyenv](https://github.com/pyenv/pyenv))
- Managing Python projects (I used to use [poetry](https://python-poetry.org/))
- Building Python packages (I used to use [poetry](https://python-poetry.org/))
- Managing Python tooling (I used to use [pipx](https://github.com/pypa/pipx))
- Running Python scripts (I would run scripts using my global Python interpreter or custom virtual environments)

As someone who works in data science, here is how I plan to integrate uv into my regular workflows.

## TL/DR

```bash
# Create a new project
mkdir example-project
cd example-project
uv init --app --python 3.12.5

# Add a packaeg
uv add httpx==0.27.2

# Remove a package
uv remove httpx

# Run code
uv run hello.py

# Run other tools
uvx ruff format .

# Generate a requirements.txt
uv pip compile pyproject.toml -o requirements.txt
```

## Install uv

```bash
curl -LsSf https://astral.sh/uv/install.sh | sh
```

## Create a new project

My first decision is what version of Python I want to use. Typically, I want to use the most recent version, which is 3.12.5 ([https://www.python.org/downloads/](https://www.python.org/downloads/)).

<Callout title="Idea">

I hope that in the future, uv will add a command so that you can see all available versions using the uv cli. For example:

```bash
uv python install --list
```

</Callout>

With my Python version selected, I am ready to bootstrap my project. Note that we pass the `--app` flag because this is a project, not a Python library.

```bash
mkdir example-project
cd example-project
uv init --app --python 3.12.5
```

My project has now been bootstrapped with the following files:

```bash
.
├── hello.py
├── pyproject.toml
└── README.md
```

**hello.py**

```python
def main():
    print("Hello from example-project!")

if __name__ == "__main__":
    main()
```

**pyproject.toml**

```toml
[project]
name = "example-project"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.12.5"
dependencies = []
```

**README.md**

*Note: the README is empty.*

```markdown

```

I do like to make one change to the pyproject.toml. Since this is a project (as opposed to a library), I want to lock into a specific version of Python. So I updated the pyrpoject.toml to use `==3.12.5` as opposed to `>=3.12.5`.

**pyproject.toml**

```toml
[project]
name = "example-project"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = "==3.12.5"
dependencies = []
```

Before proceeding, add a short project description to the README.md and the pyproject.toml description section.

## Run your code

Now that your initial packages are documented let's run some code.

```bash
uv run hello.py
# Using Python 3.12.5 interpreter at: /opt/homebrew/opt/python@3.12/bin/python3.12
# Creating virtualenv at: .venv
# Hello from example-project!
```

The first time that you invoke `uv run` uv, a few things happen:

- uv will try to find the version of Python you want on your computer. If it is not available, uv will automatically install it for you.
- uv will create a virtual environment at `./.venv`, using your desired version of Python.
- Lastly, uv will execute your script using the virtual environment.

<Callout title="Why not use `python hello.py`?">

It would also be valid to do the following:

```bash
# create the virtual environment and install packages
uv sync

# activate the virtual environment
source .venv/bin/activate

# run the code
python hello.py
```

However, I prefer to go all in with `uv`. The main advantage is that `uv run` always uses a virtual environment. You do not need to remember to create and activate one.

</Callout>

## Add a package

This toy project will use the [httpx](https://www.python-httpx.org/) package to make HTTP requests. To add httpx to our project, run the following:

```bash
uv add httpx
# Using Python 3.12.5 interpreter at: /opt/homebrew/opt/python@3.12/bin/python3.12
# Creating virtualenv at: .venv
# Resolved 8 packages in 190ms
#    Built example-project @ file:///Users/samedwardes/tmp/example-project
# Prepared 8 packages in 666ms
# Installed 8 packages in 6ms
#  + anyio==4.4.0
#  + certifi==2024.7.4
#  + example-project==0.1.0 (from file:///Users/samedwardes/tmp/example-project)
#  + h11==0.14.0
#  + httpcore==1.0.5
#  + httpx==0.27.2
#  + idna==3.8
#  + sniffio==1.3.1
```

After running `uv add`, the pyproject.toml has been updated to include httpx:

```toml
[project]
name = "example-project"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = "==3.12.5"
dependencies = [
    "httpx>=0.27.2",
]
```

Since this is a Data Science project, as opposed to a Python library that we would publish to PyPI, I prefer to explicitly lock my top-level dependencies to a specific version. Typically, I choose the latest version. Let's re-add httpx and pin the version.

```bash
uv add httpx==0.27.2
```

Now if you look at the pyproject.toml again, you can see that httpx is pinned.

```toml
[project]
name = "example-project"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = "==3.12.5"
dependencies = [
    "httpx==0.27.2",
]
```

You may have also noticed a new file in the directory.

```bash
.
├── .venv
├── hello.py
├── pyproject.toml
├── README.md
└── uv.lock          # <- New file
```

This lock file describes our top-level dependencies (httpx) and transitive dependencies (anyio, certifi, etc.). You can read more about the lock file here [https://docs.astral.sh/uv/guides/projects/#uvlock](https://docs.astral.sh/uv/guides/projects/#uvlock).

## Adding and removing packages

Additional packages can be added with the `uv add <package-name>` command. To remove packages, use `uv remove <package-name>`. The `uv remove` command is similar to the `pip uninstall` command. The most important difference is that `uv remove` not only removes the package you specify but also all of the transitive dependencies. For example, let's make the following changes:

- Add [polars](https://pola.rs/)
- Add [requests](https://docs.python-requests.org/en/latest/index.html)
- Remove [httpx](https://www.python-httpx.org/)

First, let us check all of the packages in our environment:

```bash
uv pip freeze
# anyio==4.4.0
# certifi==2024.7.4
# h11==0.14.0
# httpcore==1.0.5
# httpx==0.27.2
# idna==3.8
# sniffio==1.3.1
```

Then, use `uv add` and `uv remove` to update the environment:

```bash
uv add polars==1.6.0
uv add requests==2.32.3
uv remove httpx

uv pip freeze
# certifi==2024.7.4
# charset-normalizer==3.3.2
# idna==3.8
# polars==1.6.0
# requests==2.32.3
# urllib3==2.2.2
```

There are a few important things to note:

- polars and requests are now both installed.
- certifi is still installed, even though we uninstalled httpx. It is still in the environment because both httpx and requests depend on this library.
- anyio is removed. Only httpx depended on this library, so uv removed it from the environment.
- Both pyproject.toml and uv.lock has been updated to reflect this.

## Generating a requirements.txt

uv creates a pyproject.toml and a uv.lock file. These two files are all you need to recreate your Python environment anywhere. However, some tools won't know what to do with these files and instead require a good old fashion requirements.txt. Use the following command to generate a requirements.txt:

```bash
uv pip compile pyproject.toml -o requirements.txt
# Resolved 6 packages in 84ms
# # This file was autogenerated by uv via the following command:
# #    uv pip compile pyproject.toml -o requirements.txt
# certifi==2024.7.4
#     # via requests
# charset-normalizer==3.3.2
#     # via requests
# idna==3.8
#     # via requests
# polars==1.6.0
#     # via example-project (pyproject.toml)
# requests==2.32.3
#     # via example-project (pyproject.toml)
# urllib3==2.2.2
#     # via requests
```

**requirements.txt**

```bash
# This file was autogenerated by uv via the following command:
#    uv pip compile pyproject.toml -o requirements.txt
certifi==2024.7.4
    # via requests
charset-normalizer==3.3.2
    # via requests
idna==3.8
    # via requests
polars==1.6.0
    # via example-project (pyproject.toml)
requests==2.32.3
    # via example-project (pyproject.toml)
urllib3==2.2.2
    # via requests
```

## Running other tools (e.g. linters and formatters)

I often want to run additional tooling on my code base that is not a requirement for my project. For example, I like using the ruff formatter to format my code. I could include these tools as dependencies in my project, but I prefer to keep my project dependencies separate from my tooling dependencies. I used pipx for this in the past, but now I use the `uvx` command. For example, here is how I would format my code using ruff:

```bash
uvx ruff check --select I --fix .
uvx ruff format .
```

## Further Reading

- My original post on uv: [Replacing pip with uv for Python projects](/blog/2024-04-21-python-uv-workflow/)
- uv docs: [https://docs.astral.sh/uv/](https://docs.astral.sh/uv/)
- uv blog post: [https://astral.sh/blog/uv-unified-python-packaging](https://astral.sh/blog/uv-unified-python-packaging)
